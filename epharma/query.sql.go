// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package epharma

import (
	"context"
	"time"

	"github.com/abiiranathan/dbtypes"
)

const activateUser = `-- name: ActivateUser :exec
UPDATE users SET is_active = TRUE WHERE id = $1
`

func (q *Queries) ActivateUser(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, activateUser, id)
	return err
}

const addProductExpiry = `-- name: AddProductExpiry :exec
UPDATE products
SET expiry_dates = COALESCE(expiry_dates, ARRAY[]::date[]) || $1::date
WHERE id = $2::int
  AND NOT (expiry_dates @> ARRAY[$1::date])
  AND $1::date IS NOT NULL
`

type AddProductExpiryParams struct {
	ExpiryDate dbtypes.Date `json:"expiry_date"`
	ID         int32        `json:"id"`
}

// Add a new expiry date to the product expiry dates.
// Do this only if this expiry date is not already in the list.
func (q *Queries) AddProductExpiry(ctx context.Context, arg AddProductExpiryParams) error {
	_, err := q.db.Exec(ctx, addProductExpiry, arg.ExpiryDate, arg.ID)
	return err
}

const addProductToInvoice = `-- name: AddProductToInvoice :exec
INSERT INTO stock_in (product_id, invoice_id, quantity, cost_price, expiry_date, comment)
VALUES ($1, $2, $3, $4, $5, $6)
`

type AddProductToInvoiceParams struct {
	ProductID  int32        `json:"product_id"`
	InvoiceID  int32        `json:"invoice_id"`
	Quantity   int32        `json:"quantity"`
	CostPrice  float64      `json:"cost_price"`
	ExpiryDate dbtypes.Date `json:"expiry_date"`
	Comment    string       `json:"comment"`
}

func (q *Queries) AddProductToInvoice(ctx context.Context, arg AddProductToInvoiceParams) error {
	_, err := q.db.Exec(ctx, addProductToInvoice,
		arg.ProductID,
		arg.InvoiceID,
		arg.Quantity,
		arg.CostPrice,
		arg.ExpiryDate,
		arg.Comment,
	)
	return err
}

const annualProductSales = `-- name: AnnualProductSales :many
SELECT DATE_TRUNC('year', transaction_date)::date AS year, 
    product_id, product_name, cost_price, selling_price,
    SUM(quantity_sold)::int AS quantity_sold,
    SUM(income)::double precision AS income,
    SUM(profit)::double precision AS profit
FROM product_sales
WHERE CASE WHEN $1::text != ''
    THEN DATE_TRUNC('year', transaction_date)::date = $1::date
    ELSE TRUE
END
GROUP BY year, product_id, product_name, cost_price, selling_price
ORDER BY year DESC
`

type AnnualProductSalesRow struct {
	Year         dbtypes.Date `json:"year"`
	ProductID    int32        `json:"product_id"`
	ProductName  string       `json:"product_name"`
	CostPrice    float64      `json:"cost_price"`
	SellingPrice float64      `json:"selling_price"`
	QuantitySold int32        `json:"quantity_sold"`
	Income       float64      `json:"income"`
	Profit       float64      `json:"profit"`
}

func (q *Queries) AnnualProductSales(ctx context.Context, date string) ([]AnnualProductSalesRow, error) {
	rows, err := q.db.Query(ctx, annualProductSales, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AnnualProductSalesRow{}
	for rows.Next() {
		var i AnnualProductSalesRow
		if err := rows.Scan(
			&i.Year,
			&i.ProductID,
			&i.ProductName,
			&i.CostPrice,
			&i.SellingPrice,
			&i.QuantitySold,
			&i.Income,
			&i.Profit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const annualSalesReports = `-- name: AnnualSalesReports :many
SELECT DATE_TRUNC('year', transaction_date)::date AS year, SUM(total_income)::double precision AS total_income
FROM sales_reports
WHERE CASE WHEN $1::text != ''
    THEN DATE_TRUNC('year', transaction_date)::date = $1::date
    ELSE TRUE
END
GROUP BY year
ORDER BY year DESC
`

type AnnualSalesReportsRow struct {
	Year        dbtypes.Date `json:"year"`
	TotalIncome float64      `json:"total_income"`
}

func (q *Queries) AnnualSalesReports(ctx context.Context, date string) ([]AnnualSalesReportsRow, error) {
	rows, err := q.db.Query(ctx, annualSalesReports, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AnnualSalesReportsRow{}
	for rows.Next() {
		var i AnnualSalesReportsRow
		if err := rows.Scan(&i.Year, &i.TotalIncome); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countProducts = `-- name: CountProducts :one
SELECT COUNT(*) AS count FROM products
`

func (q *Queries) CountProducts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countProducts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createInvoice = `-- name: CreateInvoice :one
INSERT INTO
    invoices (invoice_number, purchase_date, invoice_total,
     amount_paid, supplier, user_id)
VALUES
    ($1, $2, $3, $4, $5, $6) RETURNING id, invoice_number, purchase_date, invoice_total, amount_paid, balance, supplier, user_id, created_at
`

type CreateInvoiceParams struct {
	InvoiceNumber string       `json:"invoice_number"`
	PurchaseDate  dbtypes.Date `json:"purchase_date"`
	InvoiceTotal  float64      `json:"invoice_total"`
	AmountPaid    float64      `json:"amount_paid"`
	Supplier      string       `json:"supplier"`
	UserID        int32        `json:"user_id"`
}

func (q *Queries) CreateInvoice(ctx context.Context, arg CreateInvoiceParams) (Invoice, error) {
	row := q.db.QueryRow(ctx, createInvoice,
		arg.InvoiceNumber,
		arg.PurchaseDate,
		arg.InvoiceTotal,
		arg.AmountPaid,
		arg.Supplier,
		arg.UserID,
	)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.PurchaseDate,
		&i.InvoiceTotal,
		&i.AmountPaid,
		&i.Balance,
		&i.Supplier,
		&i.UserID,
		&i.CreatedAt,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO
    products (generic_name, brand_name, quantity, 
    cost_price, selling_price, barcode, expiry_dates)
VALUES
    ($1, $2, $3, $4, $5, $6, $7) RETURNING id, generic_name, brand_name, quantity, cost_price, selling_price, expiry_dates, barcode, created_at, updated_at
`

type CreateProductParams struct {
	GenericName  string         `json:"generic_name"`
	BrandName    string         `json:"brand_name"`
	Quantity     int32          `json:"quantity"`
	CostPrice    float64        `json:"cost_price"`
	SellingPrice float64        `json:"selling_price"`
	Barcode      string         `json:"barcode"`
	ExpiryDates  []dbtypes.Date `json:"expiry_dates"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.GenericName,
		arg.BrandName,
		arg.Quantity,
		arg.CostPrice,
		arg.SellingPrice,
		arg.Barcode,
		arg.ExpiryDates,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.GenericName,
		&i.BrandName,
		&i.Quantity,
		&i.CostPrice,
		&i.SellingPrice,
		&i.ExpiryDates,
		&i.Barcode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

type CreateProductsParams struct {
	GenericName  string         `json:"generic_name"`
	BrandName    string         `json:"brand_name"`
	Quantity     int32          `json:"quantity"`
	CostPrice    float64        `json:"cost_price"`
	SellingPrice float64        `json:"selling_price"`
	Barcode      string         `json:"barcode"`
	ExpiryDates  []dbtypes.Date `json:"expiry_dates"`
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO
    transactions (items, user_id)
VALUES
    ($1, $2) RETURNING id, items, created_at, user_id
`

type CreateTransactionParams struct {
	Items  []byte `json:"items"`
	UserID int32  `json:"user_id"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction, arg.Items, arg.UserID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Items,
		&i.CreatedAt,
		&i.UserID,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO
    users (username, password)
VALUES
    ($1, $2) RETURNING id, username, password, is_active, is_admin, created_at
`

type CreateUserParams struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Username, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.IsActive,
		&i.IsAdmin,
		&i.CreatedAt,
	)
	return i, err
}

const dailyProductSales = `-- name: DailyProductSales :many
SELECT transaction_date, product_id, product_name, cost_price, selling_price, quantity_sold, income, profit FROM product_sales
WHERE CASE WHEN $1::text != ''
    THEN DATE_TRUNC('day', transaction_date)::date = $1::date
    ELSE TRUE
END
`

func (q *Queries) DailyProductSales(ctx context.Context, date string) ([]ProductSale, error) {
	rows, err := q.db.Query(ctx, dailyProductSales, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductSale{}
	for rows.Next() {
		var i ProductSale
		if err := rows.Scan(
			&i.TransactionDate,
			&i.ProductID,
			&i.ProductName,
			&i.CostPrice,
			&i.SellingPrice,
			&i.QuantitySold,
			&i.Income,
			&i.Profit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const dailySalesReports = `-- name: DailySalesReports :many
SELECT transaction_date, total_income FROM sales_reports
WHERE CASE WHEN $1::text != ''
    THEN DATE_TRUNC('day', transaction_date)::date = $1::date
    ELSE TRUE
END
ORDER BY transaction_date DESC
`

// Fetch reports
func (q *Queries) DailySalesReports(ctx context.Context, date string) ([]SalesReport, error) {
	rows, err := q.db.Query(ctx, dailySalesReports, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SalesReport{}
	for rows.Next() {
		var i SalesReport
		if err := rows.Scan(&i.TransactionDate, &i.TotalIncome); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deactivateUser = `-- name: DeactivateUser :exec
UPDATE users SET is_active = FALSE WHERE id = $1
`

func (q *Queries) DeactivateUser(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deactivateUser, id)
	return err
}

const decrementProduct = `-- name: DecrementProduct :exec
UPDATE products SET quantity=quantity - $2 WHERE id = $1
`

type DecrementProductParams struct {
	ID       int32 `json:"id"`
	Quantity int32 `json:"quantity"`
}

func (q *Queries) DecrementProduct(ctx context.Context, arg DecrementProductParams) error {
	_, err := q.db.Exec(ctx, decrementProduct, arg.ID, arg.Quantity)
	return err
}

const decrementProductQuantity = `-- name: DecrementProductQuantity :exec
UPDATE products SET quantity = quantity - $1 WHERE id = $2 AND quantity >= $1
`

type DecrementProductQuantityParams struct {
	Quantity int32 `json:"quantity"`
	ID       int32 `json:"id"`
}

func (q *Queries) DecrementProductQuantity(ctx context.Context, arg DecrementProductQuantityParams) error {
	_, err := q.db.Exec(ctx, decrementProductQuantity, arg.Quantity, arg.ID)
	return err
}

const deleteInvoice = `-- name: DeleteInvoice :exec
DELETE FROM invoices WHERE id = $1
`

func (q *Queries) DeleteInvoice(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteInvoice, id)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteProduct, id)
	return err
}

const deleteStockIn = `-- name: DeleteStockIn :exec
DELETE FROM stock_in WHERE id = $1
`

func (q *Queries) DeleteStockIn(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteStockIn, id)
	return err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
DELETE FROM transactions WHERE id = $1
`

func (q *Queries) DeleteTransaction(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteTransaction, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const demoteUser = `-- name: DemoteUser :exec
UPDATE users SET is_admin = FALSE WHERE id = $1
`

func (q *Queries) DemoteUser(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, demoteUser, id)
	return err
}

const getInvoice = `-- name: GetInvoice :one
SELECT id, invoice_number, purchase_date, invoice_total, amount_paid, balance, supplier, user_id, created_at FROM invoices WHERE id = $1
`

func (q *Queries) GetInvoice(ctx context.Context, id int32) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoice, id)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.PurchaseDate,
		&i.InvoiceTotal,
		&i.AmountPaid,
		&i.Balance,
		&i.Supplier,
		&i.UserID,
		&i.CreatedAt,
	)
	return i, err
}

const getInvoiceByNumber = `-- name: GetInvoiceByNumber :one
SELECT id, invoice_number, purchase_date, invoice_total, amount_paid, balance, supplier, user_id, created_at FROM invoices WHERE invoice_number = $1
`

func (q *Queries) GetInvoiceByNumber(ctx context.Context, invoiceNumber string) (Invoice, error) {
	row := q.db.QueryRow(ctx, getInvoiceByNumber, invoiceNumber)
	var i Invoice
	err := row.Scan(
		&i.ID,
		&i.InvoiceNumber,
		&i.PurchaseDate,
		&i.InvoiceTotal,
		&i.AmountPaid,
		&i.Balance,
		&i.Supplier,
		&i.UserID,
		&i.CreatedAt,
	)
	return i, err
}

const getProduct = `-- name: GetProduct :one
SELECT id, generic_name, brand_name, quantity, cost_price, selling_price, expiry_dates, barcode, created_at, updated_at FROM products WHERE id = $1
`

func (q *Queries) GetProduct(ctx context.Context, id int32) (Product, error) {
	row := q.db.QueryRow(ctx, getProduct, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.GenericName,
		&i.BrandName,
		&i.Quantity,
		&i.CostPrice,
		&i.SellingPrice,
		&i.ExpiryDates,
		&i.Barcode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductByBarcode = `-- name: GetProductByBarcode :one
SELECT id, generic_name, brand_name, quantity, cost_price, selling_price, expiry_dates, barcode, created_at, updated_at FROM products WHERE barcode = $1
`

func (q *Queries) GetProductByBarcode(ctx context.Context, barcode string) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByBarcode, barcode)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.GenericName,
		&i.BrandName,
		&i.Quantity,
		&i.CostPrice,
		&i.SellingPrice,
		&i.ExpiryDates,
		&i.Barcode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStockIn = `-- name: GetStockIn :one
SELECT id, product_id, invoice_id, quantity, cost_price, expiry_date, comment, created_at FROM stock_in WHERE id = $1
`

func (q *Queries) GetStockIn(ctx context.Context, id int32) (StockIn, error) {
	row := q.db.QueryRow(ctx, getStockIn, id)
	var i StockIn
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.InvoiceID,
		&i.Quantity,
		&i.CostPrice,
		&i.ExpiryDate,
		&i.Comment,
		&i.CreatedAt,
	)
	return i, err
}

const getTransaction = `-- name: GetTransaction :one
SELECT id, items, created_at, user_id FROM transactions WHERE id = $1
`

func (q *Queries) GetTransaction(ctx context.Context, id int32) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransaction, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Items,
		&i.CreatedAt,
		&i.UserID,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, username, password, is_active, is_admin, created_at FROM users WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.IsActive,
		&i.IsAdmin,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, password, is_active, is_admin, created_at FROM users WHERE username = $1 LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.IsActive,
		&i.IsAdmin,
		&i.CreatedAt,
	)
	return i, err
}

const incrementProduct = `-- name: IncrementProduct :exec
UPDATE products SET quantity=quantity + $2 WHERE id = $1
`

type IncrementProductParams struct {
	ID       int32 `json:"id"`
	Quantity int32 `json:"quantity"`
}

func (q *Queries) IncrementProduct(ctx context.Context, arg IncrementProductParams) error {
	_, err := q.db.Exec(ctx, incrementProduct, arg.ID, arg.Quantity)
	return err
}

const incrementProductQuantity = `-- name: IncrementProductQuantity :exec
UPDATE products SET quantity = quantity + $1 WHERE id = $2
`

type IncrementProductQuantityParams struct {
	Quantity int32 `json:"quantity"`
	ID       int32 `json:"id"`
}

func (q *Queries) IncrementProductQuantity(ctx context.Context, arg IncrementProductQuantityParams) error {
	_, err := q.db.Exec(ctx, incrementProductQuantity, arg.Quantity, arg.ID)
	return err
}

const invoiceItems = `-- name: InvoiceItems :many
SELECT stock_in.id, stock_in.product_id, stock_in.invoice_id, stock_in.quantity, stock_in.cost_price, stock_in.expiry_date, stock_in.comment, stock_in.created_at, 
    products.generic_name, products.brand_name
FROM stock_in
JOIN products ON stock_in.product_id = products.id
WHERE stock_in.invoice_id = (SELECT id FROM invoices WHERE invoice_number=$1 LIMIT 1)
ORDER BY stock_in.id
`

type InvoiceItemsRow struct {
	ID          int32        `json:"id"`
	ProductID   int32        `json:"product_id"`
	InvoiceID   int32        `json:"invoice_id"`
	Quantity    int32        `json:"quantity"`
	CostPrice   float64      `json:"cost_price"`
	ExpiryDate  dbtypes.Date `json:"expiry_date"`
	Comment     string       `json:"comment"`
	CreatedAt   time.Time    `json:"created_at"`
	GenericName string       `json:"generic_name"`
	BrandName   string       `json:"brand_name"`
}

// ================== StockIN Queries =========================
func (q *Queries) InvoiceItems(ctx context.Context, invoiceNumber string) ([]InvoiceItemsRow, error) {
	rows, err := q.db.Query(ctx, invoiceItems, invoiceNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InvoiceItemsRow{}
	for rows.Next() {
		var i InvoiceItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.InvoiceID,
			&i.Quantity,
			&i.CostPrice,
			&i.ExpiryDate,
			&i.Comment,
			&i.CreatedAt,
			&i.GenericName,
			&i.BrandName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvoicesPaginated = `-- name: ListInvoicesPaginated :many

SELECT id, invoice_number, purchase_date, invoice_total, amount_paid, balance, supplier, user_id, created_at FROM invoices ORDER BY id LIMIT $1 OFFSET $2
`

type ListInvoicesPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// -- Invoices queries ----------------
func (q *Queries) ListInvoicesPaginated(ctx context.Context, arg ListInvoicesPaginatedParams) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, listInvoicesPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.PurchaseDate,
			&i.InvoiceTotal,
			&i.AmountPaid,
			&i.Balance,
			&i.Supplier,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsPaginated = `-- name: ListProductsPaginated :many

SELECT id, generic_name, brand_name, quantity, cost_price, selling_price, expiry_dates, barcode, created_at, updated_at FROM products WHERE 
CASE WHEN $1::text != ''
    THEN generic_name ILIKE '%' || $1::text || '%' OR brand_name ILIKE '%' || $1::text || '%'
    ELSE TRUE
END
ORDER BY id LIMIT $3 OFFSET $2
`

type ListProductsPaginatedParams struct {
	Name string `json:"name"`
	Off  int32  `json:"off"`
	Lim  int32  `json:"lim"`
}

// -- Product queries ----------------
// Filter by name if provided.
func (q *Queries) ListProductsPaginated(ctx context.Context, arg ListProductsPaginatedParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProductsPaginated, arg.Name, arg.Off, arg.Lim)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.GenericName,
			&i.BrandName,
			&i.Quantity,
			&i.CostPrice,
			&i.SellingPrice,
			&i.ExpiryDates,
			&i.Barcode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsPaginated = `-- name: ListTransactionsPaginated :many
SELECT id, items, created_at, user_id FROM transactions ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListTransactionsPaginatedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// -- Transactions queries ----------------
func (q *Queries) ListTransactionsPaginated(ctx context.Context, arg ListTransactionsPaginatedParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactionsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Items,
			&i.CreatedAt,
			&i.UserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, username, password, is_active, is_admin, created_at FROM users
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Password,
			&i.IsActive,
			&i.IsAdmin,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const monthlyProductSales = `-- name: MonthlyProductSales :many
SELECT DATE_TRUNC('month', transaction_date)::date AS month, 
    product_id, product_name, cost_price, selling_price,
    SUM(quantity_sold)::int AS quantity_sold,
    SUM(income)::double precision AS income,
    SUM(profit)::double precision AS profit
FROM product_sales
WHERE CASE WHEN $1::text != ''
    THEN DATE_TRUNC('month', transaction_date)::date = $1::date
    ELSE TRUE
END
GROUP BY month, product_id, product_name, cost_price, selling_price
ORDER BY month DESC
`

type MonthlyProductSalesRow struct {
	Month        dbtypes.Date `json:"month"`
	ProductID    int32        `json:"product_id"`
	ProductName  string       `json:"product_name"`
	CostPrice    float64      `json:"cost_price"`
	SellingPrice float64      `json:"selling_price"`
	QuantitySold int32        `json:"quantity_sold"`
	Income       float64      `json:"income"`
	Profit       float64      `json:"profit"`
}

func (q *Queries) MonthlyProductSales(ctx context.Context, date string) ([]MonthlyProductSalesRow, error) {
	rows, err := q.db.Query(ctx, monthlyProductSales, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MonthlyProductSalesRow{}
	for rows.Next() {
		var i MonthlyProductSalesRow
		if err := rows.Scan(
			&i.Month,
			&i.ProductID,
			&i.ProductName,
			&i.CostPrice,
			&i.SellingPrice,
			&i.QuantitySold,
			&i.Income,
			&i.Profit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const monthlySalesReports = `-- name: MonthlySalesReports :many
SELECT DATE_TRUNC('month', transaction_date)::date AS month, SUM(total_income)::double precision AS total_income
FROM sales_reports
WHERE CASE WHEN $1::text != ''
    THEN DATE_TRUNC('month', transaction_date)::date = $1::date
    ELSE TRUE
END
GROUP BY month
ORDER BY month DESC
`

type MonthlySalesReportsRow struct {
	Month       dbtypes.Date `json:"month"`
	TotalIncome float64      `json:"total_income"`
}

func (q *Queries) MonthlySalesReports(ctx context.Context, date string) ([]MonthlySalesReportsRow, error) {
	rows, err := q.db.Query(ctx, monthlySalesReports, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MonthlySalesReportsRow{}
	for rows.Next() {
		var i MonthlySalesReportsRow
		if err := rows.Scan(&i.Month, &i.TotalIncome); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mostCommonProducts = `-- name: MostCommonProducts :many
SELECT DISTINCT id, generic_name, brand_name, quantity, cost_price, selling_price, expiry_dates, barcode, created_at, updated_at, product_id, count FROM products p
JOIN (
    SELECT DISTINCT (item->>'id')::int AS product_id,
           COUNT(*) AS count
    FROM transactions
    CROSS JOIN LATERAL jsonb_array_elements(items) item
    GROUP BY product_id
) t ON p.id = t.product_id
ORDER BY t.count DESC
LIMIT $1
`

type MostCommonProductsRow struct {
	ID           int32          `json:"id"`
	GenericName  string         `json:"generic_name"`
	BrandName    string         `json:"brand_name"`
	Quantity     int32          `json:"quantity"`
	CostPrice    float64        `json:"cost_price"`
	SellingPrice float64        `json:"selling_price"`
	ExpiryDates  []dbtypes.Date `json:"expiry_dates"`
	Barcode      string         `json:"barcode"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
	ProductID    int32          `json:"product_id"`
	Count        int64          `json:"count"`
}

// Ruturn 10 most common products in transactions
// order by count
func (q *Queries) MostCommonProducts(ctx context.Context, limit int32) ([]MostCommonProductsRow, error) {
	rows, err := q.db.Query(ctx, mostCommonProducts, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MostCommonProductsRow{}
	for rows.Next() {
		var i MostCommonProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.GenericName,
			&i.BrandName,
			&i.Quantity,
			&i.CostPrice,
			&i.SellingPrice,
			&i.ExpiryDates,
			&i.Barcode,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProductID,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const promoteUser = `-- name: PromoteUser :exec
UPDATE users SET is_admin = TRUE WHERE id = $1
`

func (q *Queries) PromoteUser(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, promoteUser, id)
	return err
}

const removeProductExpiry = `-- name: RemoveProductExpiry :exec
UPDATE products
SET expiry_dates = array_remove(expiry_dates, $1::date)
WHERE id = $2::int
`

type RemoveProductExpiryParams struct {
	ExpiryDate dbtypes.Date `json:"expiry_date"`
	ID         int32        `json:"id"`
}

func (q *Queries) RemoveProductExpiry(ctx context.Context, arg RemoveProductExpiryParams) error {
	_, err := q.db.Exec(ctx, removeProductExpiry, arg.ExpiryDate, arg.ID)
	return err
}

const replaceProductExpiry = `-- name: ReplaceProductExpiry :exec
UPDATE products SET expiry_dates = $1 WHERE id = $2
`

type ReplaceProductExpiryParams struct {
	ExpiryDates []dbtypes.Date `json:"expiry_dates"`
	ID          int32          `json:"id"`
}

func (q *Queries) ReplaceProductExpiry(ctx context.Context, arg ReplaceProductExpiryParams) error {
	_, err := q.db.Exec(ctx, replaceProductExpiry, arg.ExpiryDates, arg.ID)
	return err
}

const searchInvoices = `-- name: SearchInvoices :many
SELECT id, invoice_number, purchase_date, invoice_total, amount_paid, balance, supplier, user_id, created_at FROM invoices WHERE invoice_number = $1
`

func (q *Queries) SearchInvoices(ctx context.Context, invoiceNumber string) ([]Invoice, error) {
	rows, err := q.db.Query(ctx, searchInvoices, invoiceNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invoice{}
	for rows.Next() {
		var i Invoice
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceNumber,
			&i.PurchaseDate,
			&i.InvoiceTotal,
			&i.AmountPaid,
			&i.Balance,
			&i.Supplier,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProducts = `-- name: SearchProducts :many
SELECT id, generic_name, brand_name, quantity, cost_price, selling_price, expiry_dates, barcode, created_at, updated_at FROM products
WHERE
    generic_name ILIKE '%' || $1::text || '%'
    OR brand_name ILIKE '%' || $1::text || '%'
ORDER BY id LIMIT 50
`

// Full text search for the products table
func (q *Queries) SearchProducts(ctx context.Context, name string) ([]Product, error) {
	rows, err := q.db.Query(ctx, searchProducts, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Product{}
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.GenericName,
			&i.BrandName,
			&i.Quantity,
			&i.CostPrice,
			&i.SellingPrice,
			&i.ExpiryDates,
			&i.Barcode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvoice = `-- name: UpdateInvoice :exec
UPDATE invoices SET 
        invoice_number = $1, 
        purchase_date = $2, 
        invoice_total = $3, 
        amount_paid = $4, 
        supplier = $5, 
        user_id = $6 
        WHERE id = $7
`

type UpdateInvoiceParams struct {
	InvoiceNumber string       `json:"invoice_number"`
	PurchaseDate  dbtypes.Date `json:"purchase_date"`
	InvoiceTotal  float64      `json:"invoice_total"`
	AmountPaid    float64      `json:"amount_paid"`
	Supplier      string       `json:"supplier"`
	UserID        int32        `json:"user_id"`
	ID            int32        `json:"id"`
}

func (q *Queries) UpdateInvoice(ctx context.Context, arg UpdateInvoiceParams) error {
	_, err := q.db.Exec(ctx, updateInvoice,
		arg.InvoiceNumber,
		arg.PurchaseDate,
		arg.InvoiceTotal,
		arg.AmountPaid,
		arg.Supplier,
		arg.UserID,
		arg.ID,
	)
	return err
}

const updateProduct = `-- name: UpdateProduct :exec
UPDATE products SET generic_name = $1, brand_name = $2, 
    quantity = $3, cost_price = $4, selling_price = $5, 
    barcode = $6, expiry_dates=$7 WHERE id = $8
`

type UpdateProductParams struct {
	GenericName  string         `json:"generic_name"`
	BrandName    string         `json:"brand_name"`
	Quantity     int32          `json:"quantity"`
	CostPrice    float64        `json:"cost_price"`
	SellingPrice float64        `json:"selling_price"`
	Barcode      string         `json:"barcode"`
	ExpiryDates  []dbtypes.Date `json:"expiry_dates"`
	ID           int32          `json:"id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) error {
	_, err := q.db.Exec(ctx, updateProduct,
		arg.GenericName,
		arg.BrandName,
		arg.Quantity,
		arg.CostPrice,
		arg.SellingPrice,
		arg.Barcode,
		arg.ExpiryDates,
		arg.ID,
	)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users SET username = $1, 
password= CASE WHEN  $2::bool
THEN $3
    ELSE password
    END
WHERE id = $4
`

type UpdateUserParams struct {
	Username       string `json:"username"`
	UpdatePassword bool   `json:"update_password"`
	Password       string `json:"password"`
	ID             int32  `json:"id"`
}

// Only update password if it's not empty
func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.Username,
		arg.UpdatePassword,
		arg.Password,
		arg.ID,
	)
	return err
}
